SuperAgent Project Setup: Comprehensive Implementation Guide

Executive Summary

This comprehensive report outlines the complete setup process for the SuperAgent Project, a modern web application using FastAPI for the backend and Next.js for the frontend. The report details the five key phases of project implementation: project structure setup, backend development, frontend development, documentation, and testing & deployment processes. Each section provides specific implementation instructions that development teams can follow to establish a solid foundation for the project.


1. Project Structure Setup

1.1 Creating Main Project Directories

To establish a well-organized project structure, create the following directory hierarchy:


superagent/
├── frontend/
├── backend/
├── design-assets/
└── docs/


Execute the following commands to create this structure:


mkdir -p superagent/{frontend,backend,design-assets,docs}


1.2 Initializing Git Repository

Set up version control with Git to track project changes:


cd superagent
git init
touch .gitignore


Add essential patterns to `.gitignore`:


# Node dependencies
node_modules/
.next/

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.env
venv/
env/

# IDE files
.vscode/
.idea/

# Build files
dist/
build/

# Logs
*.log


1.3 Creating README.md with Project Overview

Create a comprehensive README.md file at the root level:


# SuperAgent Project

## Overview
SuperAgent is a [brief description of what the application does]. The system provides [key functionality] through an intuitive interface and robust API.

## Technology Stack
- **Frontend**: Next.js, React
- **Backend**: FastAPI, Python
- **Database**: [Database technology]
- **Authentication**: [Auth method]
- **Deployment**: [Deployment platform]

## Project Structure
- `frontend/`: Next.js application
- `backend/`: FastAPI server
- `design-assets/`: UI/UX design files and assets
- `docs/`: Project documentation

## Getting Started
[Instructions for setting up development environment]

## Contributing
[Guidelines for contributing to the project]

## License
[License information]


1.4 Setting Up Basic Configuration Files

Create essential configuration files for development consistency:

1. **Environment Variables Templates**:


# Create backend .env.example
cat > backend/.env.example << EOF
# API Configuration
API_PORT=8000
API_HOST=0.0.0.0
DEBUG=False

# Database
DB_HOST=localhost
DB_PORT=5432
DB_NAME=superagent
DB_USER=postgres
DB_PASSWORD=password

# Stripe
STRIPE_API_KEY=sk_test_your_key_here
STRIPE_WEBHOOK_SECRET=whsec_your_key_here
EOF

# Create frontend .env.example
cat > frontend/.env.example << EOF
NEXT_PUBLIC_API_URL=http://localhost:8000
NEXT_PUBLIC_STRIPE_PUBLIC_KEY=pk_test_your_key_here
EOF

1. **Editor Configuration**:


# Create .editorconfig
cat > .editorconfig << EOF
root = true

[*]
end_of_line = lf
insert_final_newline = true
charset = utf-8
trim_trailing_whitespace = true
indent_style = space
indent_size = 2

[*.{py,md}]
indent_size = 4

[Makefile]
indent_style = tab
EOF


2. Backend Setup

2.1 Setting Up FastAPI Structure

Set up a structured FastAPI application:


cd backend
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install fastapi uvicorn sqlalchemy pydantic python-dotenv stripe pytest


Create the backend structure:


backend/
├── app/
│   ├── __init__.py
│   ├── main.py
│   ├── core/
│   │   ├── __init__.py
│   │   ├── config.py
│   │   └── security.py
│   ├── api/
│   │   ├── __init__.py
│   │   ├── routes/
│   │   │   ├── __init__.py
│   │   │   └── api.py
│   │   └── endpoints/
│   │       ├── __init__.py
│   │       └── users.py
│   ├── models/
│   │   ├── __init__.py
│   │   └── user.py
│   ├── schemas/
│   │   ├── __init__.py
│   │   └── user.py
│   ├── db/
│   │   ├── __init__.py
│   │   ├── base.py
│   │   └── session.py
│   ├── services/
│   │   ├── __init__.py
│   │   └── metering.py
│   └── billing/
│       ├── __init__.py
│       └── stripe.py
├── tests/
│   ├── __init__.py
│   └── test_api.py
├── .env
├── .env.example
├── requirements.txt
└── README.md


Create the main FastAPI application in `app/main.py`:


from fastapi import FastAPI
from app.api.routes.api import router as api_router
from app.core.config import settings

app = FastAPI(
    title=settings.PROJECT_NAME,
    description=settings.PROJECT_DESCRIPTION,
    version=settings.VERSION,
    openapi_url=f"{settings.API_V1_STR}/openapi.json"
)

app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/")
async def root():
    return {"message": "Welcome to SuperAgent API"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("app.main:app", host="0.0.0.0", port=8000, reload=True)


2.2 Creating API Metering Module

Implement API usage monitoring in `app/services/metering.py`:


from datetime import datetime
from typing import Dict, Optional
from fastapi import Request, Response
import time
import uuid
from app.models.usage import APIUsage
from app.db.session import get_db

class APIMetering:
    """Tracks and logs API usage for billing purposes"""
    
    @staticmethod
    async def track_request(request: Request, call_next):
        """Middleware to track API calls"""
        request_id = str(uuid.uuid4())
        start_time = time.time()
        
        # Extract user ID from request (authentication dependent)
        user_id = getattr(request.state, "user_id", None)
        
        response = await call_next(request)
        
        # Calculate request duration
        duration = time.time() - start_time
        
        # Log the API usage
        db = next(get_db())
        usage = APIUsage(
            request_id=request_id,
            user_id=user_id,
            endpoint=f"{request.method} {request.url.path}",
            timestamp=datetime.utcnow(),
            duration_ms=int(duration * 1000),
            status_code=response.status_code,
            request_size=int(request.headers.get("content-length", 0)),
            response_size=int(response.headers.get("content-length", 0))
        )
        db.add(usage)
        db.commit()
        
        return response
    
    @staticmethod
    def get_usage_stats(user_id: str, start_date: datetime, end_date: datetime) -> Dict:
        """Get usage statistics for a specific user in date range"""
        db = next(get_db())
        query = db.query(APIUsage).filter(
            APIUsage.user_id == user_id,
            APIUsage.timestamp >= start_date,
            APIUsage.timestamp <= end_date
        )
        
        total_calls = query.count()
        successful_calls = query.filter(APIUsage.status_code < 400).count()
        failed_calls = total_calls - successful_calls
        
        return {
            "total_calls": total_calls,
            "successful_calls": successful_calls,
            "failed_calls": failed_calls,
            "success_rate": successful_calls / total_calls if total_calls > 0 else 0
        }


Add the metering middleware in `app/main.py`:


from app.services.metering import APIMetering

# Add this line before defining routes
app.middleware("http")(APIMetering.track_request)


2.3 Implementing Stripe Billing Integration

Create the Stripe integration in `app/billing/stripe.py`:


import stripe
from typing import Dict, List, Optional
from fastapi import HTTPException
from app.core.config import settings
from app.models.subscription import Subscription
from app.db.session import get_db

# Initialize Stripe
stripe.api_key = settings.STRIPE_API_KEY

class StripeBilling:
    """Handles Stripe billing operations"""
    
    @staticmethod
    def create_customer(email: str, name: str) -> Dict:
        """Create a new customer in Stripe"""
        try:
            customer = stripe.Customer.create(
                email=email,
                name=name,
                metadata={"source": "superagent"}
            )
            return customer
        except stripe.error.StripeError as e:
            raise HTTPException(status_code=400, detail=f"Stripe error: {str(e)}")
    
    @staticmethod
    def create_subscription(customer_id: str, price_id: str) -> Dict:
        """Create a subscription for a customer"""
        try:
            subscription = stripe.Subscription.create(
                customer=customer_id,
                items=[{"price": price_id}],
                expand=["latest_invoice.payment_intent"]
            )
            
            # Store subscription details in database
            db = next(get_db())
            db_subscription = Subscription(
                user_id=customer_id,  # Assuming customer_id is user_id
                stripe_subscription_id=subscription.id,
                status=subscription.status,
                current_period_start=subscription.current_period_start,
                current_period_end=subscription.current_period_end,
                price_id=price_id
            )
            db.add(db_subscription)
            db.commit()
            
            return subscription
        except stripe.error.StripeError as e:
            raise HTTPException(status_code=400, detail=f"Stripe error: {str(e)}")
    
    @staticmethod
    def get_subscription(subscription_id: str) -> Dict:
        """Get subscription details"""
        try:
            return stripe.Subscription.retrieve(subscription_id)
        except stripe.error.StripeError as e:
            raise HTTPException(status_code=400, detail=f"Stripe error: {str(e)}")
    
    @staticmethod
    def cancel_subscription(subscription_id: str) -> Dict:
        """Cancel a subscription"""
        try:
            return stripe.Subscription.delete(subscription_id)
        except stripe.error.StripeError as e:
            raise HTTPException(status_code=400, detail=f"Stripe error: {str(e)}")
    
    @staticmethod
    def handle_webhook(payload: bytes, signature: str) -> Dict:
        """Handle Stripe webhook events"""
        try:
            event = stripe.Webhook.construct_event(
                payload, signature, settings.STRIPE_WEBHOOK_SECRET
            )
            
            # Handle different event types
            if event.type == 'invoice.payment_succeeded':
                # Update subscription status
                invoice = event.data.object
                db = next(get_db())
                subscription = db.query(Subscription).filter_by(
                    stripe_subscription_id=invoice.subscription
                ).first()
                
                if subscription:
                    subscription.status = 'active'
                    db.commit()
                    
            elif event.type == 'invoice.payment_failed':
                # Handle failed payment
                invoice = event.data.object
                db = next(get_db())
                subscription = db.query(Subscription).filter_by(
                    stripe_subscription_id=invoice.subscription
                ).first()
                
                if subscription:
                    subscription.status = 'past_due'
                    db.commit()
            
            return {"status": "success"}
        except stripe.error.StripeError as e:
            raise HTTPException(status_code=400, detail=f"Stripe error: {str(e)}")


Create an endpoint for Stripe webhooks in `app/api/endpoints/billing.py`:


from fastapi import APIRouter, Request, Depends, Header
from typing import Optional
from app.billing.stripe import StripeBilling

router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request, stripe_signature: str = Header(None)):
    """Handle Stripe webhooks"""
    payload = await request.body()
    return StripeBilling.handle_webhook(payload, stripe_signature)


2.4 Configuring Database Models

Define the database models in appropriate files:


`app/models/user.py`:

from sqlalchemy import Column, Integer, String, Boolean, DateTime
from sqlalchemy.sql import func
from app.db.base import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String)
    is_active = Column(Boolean, default=True)
    is_superuser = Column(Boolean, default=False)
    stripe_customer_id = Column(String, unique=True, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())


`app/models/subscription.py`:

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from app.db.base import Base

class Subscription(Base):
    __tablename__ = "subscriptions"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    stripe_subscription_id = Column(String, unique=True, nullable=False)
    status = Column(String, nullable=False)
    price_id = Column(String, nullable=False)
    current_period_start = Column(Integer)  # Unix timestamp from Stripe
    current_period_end = Column(Integer)    # Unix timestamp from Stripe
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, onupdate=func.now())
    
    # Relationship
    user = relationship("User", back_populates="subscriptions")


`app/models/usage.py`:

from sqlalchemy import Column, Integer, String, DateTime, Float
from app.db.base import Base

class APIUsage(Base):
    __tablename__ = "api_usage"
    
    id = Column(Integer, primary_key=True, index=True)
    request_id = Column(String, unique=True, index=True)
    user_id = Column(Integer, nullable=True)
    endpoint = Column(String, nullable=False)
    timestamp = Column(DateTime, nullable=False)
    duration_ms = Column(Integer, nullable=False)
    status_code = Column(Integer, nullable=False)
    request_size = Column(Integer, default=0)
    response_size = Column(Integer, default=0)


Set up the database connection in `app/db/base.py`:

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

SQLALCHEMY_DATABASE_URL = settings.DATABASE_URL

engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()


3. Frontend Setup

3.1 Initializing Next.js Project

Set up the Next.js frontend:


cd ../frontend
npx create-next-app@latest . --typescript


Install additional dependencies:


npm install axios formik yup react-query @stripe/stripe-js @stripe/react-stripe-js swr tailwindcss
npm install --save-dev jest @testing-library/react @testing-library/jest-dom


Configure Tailwind CSS:


npx tailwindcss init -p


Update `tailwind.config.js`:


/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx}",
    "./components/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: '#0070f3',
        secondary: '#ff4081',
        background: '#f5f5f5',
      },
    },
  },
  plugins: [],
}


3.2 Creating Basic UI Components

Create a components directory structure:


frontend/
└── components/
    ├── common/
    │   ├── Button.tsx
    │   ├── Card.tsx
    │   ├── Input.tsx
    │   └── Navbar.tsx
    ├── layout/
    │   ├── Footer.tsx
    │   ├── Header.tsx
    │   └── Layout.tsx
    └── features/
        ├── auth/
        │   ├── LoginForm.tsx
        │   └── RegisterForm.tsx
        └── billing/
            ├── PricingTable.tsx
            └── SubscriptionManager.tsx


Example button component (`components/common/Button.tsx`):


import React from 'react';

type ButtonProps = {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'outline';
  size?: 'small' | 'medium' | 'large';
  fullWidth?: boolean;
  onClick?: () => void;
  type?: 'button' | 'submit' | 'reset';
  disabled?: boolean;
};

const Button = ({
  children,
  variant = 'primary',
  size = 'medium',
  fullWidth = false,
  onClick,
  type = 'button',
  disabled = false,
}: ButtonProps) => {
  const baseClasses = 'rounded font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2';
  
  const variantClasses = {
    primary: 'bg-primary text-white hover:bg-primary-dark focus:ring-primary',
    secondary: 'bg-secondary text-white hover:bg-secondary-dark focus:ring-secondary',
    outline: 'bg-transparent border border-gray-300 text-gray-700 hover:bg-gray-50 focus:ring-primary',
  };
  
  const sizeClasses = {
    small: 'py-1 px-3 text-sm',
    medium: 'py-2 px-4',
    large: 'py-3 px-6 text-lg',
  };
  
  const widthClasses = fullWidth ? 'w-full' : '';
  const disabledClasses = disabled ? 'opacity-50 cursor-not-allowed' : '';

  return (
    <button
      type={type}
      onClick={onClick}
      disabled={disabled}
      className={`${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]} ${widthClasses} ${disabledClasses}`}
    >
      {children}
    </button>
  );
};

export default Button;


Example layout component (`components/layout/Layout.tsx`):


import React from 'react';
import Header from './Header';
import Footer from './Footer';

type LayoutProps = {
  children: React.ReactNode;
};

const Layout = ({ children }: LayoutProps) => {
  return (
    <div className="flex flex-col min-h-screen">
      <Header />
      <main className="flex-grow">{children}</main>
      <Footer />
    </div>
  );
};

export default Layout;


3.3 Implementing Branding Elements

Create a styles directory for branding:


frontend/
└── styles/
    ├── globals.css
    └── theme.ts


Update `globals.css` with brand styling:


@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --primary-color: #0070f3;
  --secondary-color: #ff4081;
  --background-color: #f5f5f5;
  --text-color: #333;
  --success-color: #4caf50;
  --warning-color: #ff9800;
  --error-color: #f44336;
}

body {
  background-color: var(--background-color);
  color: var(--text-color);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,
    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
}

.logo {
  font-weight: 700;
  font-size: 1.5rem;
  background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

/* Common component styles */
@layer components {
  .card {
    @apply bg-white rounded-lg shadow-md p-6;
  }
  
  .container-narrow {
    @apply max-w-3xl mx-auto px-4;
  }
  
  .container-wide {
    @apply max-w-7xl mx-auto px-4;
  }
  
  .section {
    @apply py-12;
  }
}


Create a theme file for branding constants:


// styles/theme.ts
export const theme = {
  colors: {
    primary: '#0070f3',
    primaryDark: '#0058c3',
    primaryLight: '#3391ff',
    secondary: '#ff4081',
    secondaryDark: '#c60055',
    secondaryLight: '#ff79b0',
    background: '#f5f5f5',
    text: '#333',
    success: '#4caf50',
    warning: '#ff9800',
    error: '#f44336',
    gray: {
      50: '#fafafa',
      100: '#f5f5f5',
      200: '#eeeeee',
      300: '#e0e0e0',
      400: '#bdbdbd',
      500: '#9e9e9e',
      600: '#757575',
      700: '#616161',
      800: '#424242',
      900: '#212121',
    },
  },
  typography: {
    fontFamily: "'Inter', sans-serif",
    heading: {
      fontWeight: 700,
      lineHeight: 1.2,
    },
    body: {
      fontWeight: 400,
      lineHeight: 1.5,
    },
  },
  spacing: {
    xs: '0.25rem',
    sm: '0.5rem',
    md: '1rem',
    lg: '1.5rem',
    xl: '2rem',
    xxl: '3rem',
  },
  breakpoints: {
    sm: '640px',
    md: '768px',
    lg: '1024px',
    xl: '1280px',
    '2xl': '1536px',
  },
};

export default theme;


3.4 Setting Up API Client for Backend Communication

Create an API client for backend communication:


frontend/
└── lib/
    ├── api.ts
    ├── auth.ts
    └── hooks/
        ├── useAuth.ts
        └── useSubscription.ts


Implement the API client (`lib/api.ts`):


import axios from 'axios';

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

const api = axios.create({
  baseURL: `${API_URL}/api/v1`,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor for adding auth token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor for error handling
api.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    // Handle 401 Unauthorized errors (token expired)
    if (error.response && error.response.status === 401) {
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

// API endpoints
export const endpoints = {
  auth: {
    login: '/auth/login',
    register: '/auth/register',
    refreshToken: '/auth/refresh',
    me: '/auth/me',
  },
  users: {
    list: '/users',
    detail: (id: number) => `/users/${id}`,
    update: (id: number) => `/users/${id}`,
  },
  subscriptions: {
    list: '/subscriptions',
    create: '/subscriptions',
    detail: (id: string) => `/subscriptions/${id}`,
    cancel: (id: string) => `/subscriptions/${id}`,
  },
  usage: {
    stats: '/usage/stats',
  },
};

export default api;


Create authentication helper (`lib/auth.ts`):


import api, { endpoints } from './api';

export type LoginCredentials = {
  email: string;
  password: string;
};

export type RegisterData = {
  email: string;
  password: string;
  fullName: string;
};

export type AuthUser = {
  id: number;
  email: string;
  fullName: string;
  isActive: boolean;
  stripeCustomerId?: string;
};

export const login = async (credentials: LoginCredentials) => {
  const response = await api.post(endpoints.auth.login, credentials);
  const { access_token } = response.data;
  localStorage.setItem('token', access_token);
  return access_token;
};

export const register = async (data: RegisterData) => {
  const response = await api.post(endpoints.auth.register, data);
  return response.data;
};

export const logout = () => {
  localStorage.removeItem('token');
  window.location.href = '/login';
};

export const getCurrentUser = async (): Promise<AuthUser> => {
  const response = await api.get(endpoints.auth.me);
  return response.data;
};


Create a custom hook for authentication (`lib/hooks/useAuth.ts`):


import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { getCurrentUser, login, logout, AuthUser, LoginCredentials } from '../auth';

export function useAuth() {
  const [user, setUser] = useState<AuthUser | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  useEffect(() => {
    // Check for token and fetch user data on mount
    const token = localStorage.getItem('token');
    if (!token) {
      setLoading(false);
      return;
    }

    async function loadUser() {
      try {
        const userData = await getCurrentUser();
        setUser(userData);
      } catch (err) {
        console.error('Failed to fetch user data:', err);
        setError('Session expired. Please login again.');
        logout();
      } finally {
        setLoading(false);
      }
    }

    loadUser();
  }, []);

  const handleLogin = async (credentials: LoginCredentials) => {
    setLoading(true);
    setError(null);
    
    try {
      await login(credentials);
      const userData = await getCurrentUser();
      setUser(userData);
      router.push('/dashboard');
      return true;
    } catch (err: any) {
      setError(err.response?.data?.detail || 'Login failed. Please try again.');
      return false;
    } finally {
      setLoading(false);
    }
  };

  const handleLogout = () => {
    logout();
    setUser(null);
  };

  return {
    user,
    loading,
    error,
    login: handleLogin,
    logout: handleLogout,
    isAuthenticated: !!user,
  };
}


4. Documentation

4.1 Creating Technical Documentation

Set up the documentation directory:


docs/
├── technical/
│   ├── architecture.md
│   ├── backend.md
│   ├── frontend.md
│   └── database.md
├── api/
│   ├── overview.md
│   ├── authentication.md
│   ├── users.md
│   ├── subscriptions.md
│   └── usage.md
├── user-guides/
│   ├── getting-started.md
│   ├── authentication.md
│   ├── dashboard.md
│   └── billing.md
└── deployment/
    ├── development.md
    ├── staging.md
    └── production.md


Create technical architecture documentation (`docs/technical/architecture.md`):


# SuperAgent Technical Architecture

## Overview

SuperAgent is built as a modern web application using FastAPI for the backend and Next.js for the frontend. This document outlines the high-level architecture and design decisions.

## System Architecture


                                  ┌──────────────┐
                                  │              │
                                  │  Next.js     │
                                  │  Frontend    │
                                  │              │
                                  └───────┬──────┘
                                          │
                                          │ HTTP/HTTPS
                                          │
                                  ┌───────▼──────┐
                                  │              │
                                  │  FastAPI     │
                                  │  Backend     │
                                  │              │
                                  └───┬───┬──────┘
                                      │   │
                    ┌─────────────────┘   └────────────────┐
                    │                                      │
            ┌───────▼───────┐                      ┌───────▼───────┐
            │               │                      │               │
            │  PostgreSQL   │                      │  Stripe API   │
            │  Database     │                      │               │
            │               │                      │               │
            └───────────────┘                      └───────────────┘


## Component Responsibilities

### Frontend (Next.js)

- User interface rendering
- Client-side state management
- API communication
- Form validation
- Payment processing UI

### Backend (FastAPI)

- API endpoints
- Authentication and authorization
- Business logic
- Stripe integration
- API usage metering
- Database interaction

### Database (PostgreSQL)

- User data
- Subscription information
- API usage tracking
- Application settings

## Authentication Flow

1. User submits login credentials
2. Backend validates credentials and issues JWT token
3. Frontend stores token in localStorage
4. Subsequent API requests include token in Authorization header
5. Backend validates token for protected endpoints

## Subscription and Billing Flow

1. User